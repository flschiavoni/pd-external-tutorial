% ----------------------------------------------------------------------------
% Introdução
% ----------------------------------------------------------------------------
 
\chapter{Introdução}

Pure Data, ou simplesmente Pd, é um ambiente visual de programação musical que permite a criação de
aplicações musicais complexas a partir da combinação de componentes visuais
mais simples chamados \textbf{objetos}. As distribuições oficiais do Pure Data
contêm diversos objetos prontos para o uso, mas também permitem a extensão de
suas funcionalidades através da criação de novos objetos utilizando C/C++.
Desta forma, novas linhas de código escritas pelo usuário são compilados como
bibliotecas dinâmicas e podem ser carregadas pelo programa em tempo de
execução. Objetos desta forma levam o nome de \textbf{\externals}.

Este é um tutorial prático para o desenvolvimento de \externals em C para o
Pure Data. A iniciativa de escrever este documento surgiu no primeiro semestre
de 2011, durante a disciplina de Computação Musical ministrada pelo professor
Marcelo Gomes de Queiroz no Instituto de Matemática e Estatística da
Universidade de São Paulo. A intenção deste tutorial é auxiliar programadores
a desenvolver \externals de maneira bastante simples através de exemplos
práticos.

Mais do que ampliar a gama de objetos do Pure Data e criar novos objetos, o
objetivo deste trabalho é também fornecer ao pesquisador de computação musical
uma ferramenta para implementar e testar algoritmos de processamento de áudio
para caráter de estudo. Isto significa que podemos reimplementar várias coisas
que já existem no Pure Data simplesmente porque é didático programar e colocar
algoritmos para funcionar.

\section{Escrevendo \externals}

O código fonte do Pure Data é organizado de acordo com convenções de
programação orientada a objetos. Para o desenvolvimento de \externals, é
necessário seguir estas convenções e fornecer ao ambiente uma nova classe com
alguns métodos específicos, como veremos mais adiante. Para desenvolver para o
Pure Data, é necessário importar o arquivo de cabeçalho
\texttt{m\_pd.h}\footnote{http://pure-data.git.sourceforge.net/git/gitweb.cgi?p=pure-data/pure-data;a=blob\_plain;f=src/m\_pd.h;hb=HEAD},
que contém definições de constantes, tipos e funções.

Uma boa fonte de informação é o tutorial de
\externals\footnote{http://iem.at/pd/externals-HOWTO/pd-externals-HOWTO.pdf}
escrito pelo IOHannes\footnote{http://puredata.info/author/zmoelnig}, um dos
programadores do Pure Data. Apesar de ter utilizado este documento como ponto
de partida, boa parte do que está incluso no presente tutorial foi aprendido a
partir da leitura do código-fonte de \externals contidos no repositório
oficial do Pure
Data\footnote{http://pure-data.svn.sourceforge.net/viewvc/pure-data/trunk/externals/}.

Navegando pelos códigos-fonte deste repositório você poderá notar que os programadores
que escreveram os externals que hoje estão disponível para o Pd seguiram estas convenções
e por isto a leitura destes códigos-fonte pode ser didática e simples.

Por esta razão, o primeiro conselho que damos para quem irá escrever \externals é seguir
estas convenções, mesmo que as mesmas não sejam a maneira como você está acostumado a 
programar deste jeito pois assim seu código também será didático e simples de entender.

Este tutorial não pretende cobrir os algoritmos de processamento de sinais mas explicar
como implementar estes algoritmos como objetos do Pd. Para processamento de sinais há
uma vasta bibliografia disponível que possui os algoritmos e o ferramental matemático
necessário para sua implementação.

\todo{Será que podemos citar aqui algum livro ou material para DSP?}
 

\section{Organização do código-fonte e do objeto compilado}
\label{sec:organizacao}

Um novo \external corresponde a uma nova classe na arquitetura orientada a
objetos do Pure Data. Para que o carregamento da biblioteca dinâmica
em tempo de execução funcione corretamente, é necessário que o
arquivo binário produzido possua o mesmo nome que a classe correspondente ao
\external.

Para criar, por exemplo, um \external chamado ``passa-baixas", podemos
escrever seu código-fonte em um arquivo chamado \texttt{passa-baixas.c}, e em
seguida compilar um objeto de biblioteca compartilhada chamado
\texttt{passa-baixas.pd\_linux}, no caso do sistema GNU/Linux. Outras
arquiteturas de sistema utilizam outras extensões para o nome do objeto com a
biblioteca compartilhada do \external, como por exemplo \texttt{.dll} (M\$
Windows), \texttt{.pd\_irix5} (SGI Irix) ou \texttt{.pd\_darwin} (Mac OS X).

\textbf{Importante:} O nome do arquivo com o código-fonte não possui formato
obrigatório, mas o nome do objeto compilado com a biblioteca dinâmica deve
sempre corresponder ao nome da classe, assim como sua extensão deve sempre
corresponder à arquitetura do sistema utilizado.

O mesmo cuidado é recomendado para os métodos que serão definidos internamente
no objeto. Os nomes de métodos que serão apresentados neste material seguem o padrão
encontrado no repositório do Pd. É fortemente recomendado que o mesmo padrão seja
utilizado em seu texto.

\section{Compilação}
\label{sec:compiling}

Para criar um objeto binário que pode ser carregado no Pure Data em tempo de
execução, primeiro compilamos o código fonte, criando assim um ou mais objetos
intermediários, e em seguida utilizamos um ligador (\emph{linker}) para criar
um objeto de biblioteca compartilhada.

No GNU/Linux, uma forma de realizar o processo
\texttt{example01.c} $\rightarrow$ \texttt{example01.o} $\rightarrow$
\texttt{example01.pd\_linux} é a seguinte:

\vspace{1em}
\begin{lstlisting}
EXTNAME=example01
cc -DPD -fPIC -Wall -o ${EXTNAME}.o -c ${EXTNAME}.c
ld -shared -lc -lm -o ${EXTNAME}.pd_linux ${EXTNAME}.o
rm ${EXTNAME}.o
\end{lstlisting}

A opção de compilação \texttt{-fPIC} resulta na criação de código binário que
roda independente de sua posição na memória, adequado para geração de
bibliotecas compartilhadas. A opção \texttt{-shared} passada para o ligador
determina a criação de uma biblioteca compartilhada.

Para facilitar a compilação, é interessante utilizar um \texttt{makefile}. Os
exemplos deste tutorial estão acompanhadas de um \texttt{makefile} produzido
pelo professor Marcelo Queiroz e adaptado para este tutorial.

Tem uma dezena de jeito de compilar pro Windows, usando o Mingw ou o C++ Builder.
Aqui\footnote{http://puredata.hurleur.com/sujet-1029-problem-compiling-external-windows}
 temos exemplos e muitas discussões de como compilar externals no Windows.

\todo{Será que compensa testarmos isto tudo?}

\subsection{Misturando código C e C++}

Existem algumas diferenças entre compiladores C e C++ que tornam a sintaxe das
linguagens incompatíveis, gerando resultados diferentes para um mesmo trecho
de código. Um exemplo disso que influencia o funcionamento de \externals no
Pure Data é a geração da tabela de símbolos dos objetos binários.

Compiladores C++ realizam um processo chamado \emph{name mangling} (ou
``dilaceramento de nomes"), que consiste em alterar o nome de funções,
estruturas, classes, etc, incluindo informações sobre o espaço de nomes do
objeto em questão. Isto resulta em nome diferentes gravados nas tabelas de
símbolos dos objetos binários, o que pode confundir o Pure Data no momento do
carregamento de um \external.

Para garantir que um compilador C++ gere nomes compatíveis com objetos
binários C, utilize a expressão \texttt{extern "C"} na frente dos nomes das
funções que serão chamadas pelo Pure Data:

\begin{lstlisting}
extern "C" example01_setup(void);
extern "C" example01_new(void);
\end{lstlisting}


\section{Arquivos de ajuda}

É importante distribuir, junto com novos \externals, um arquivo de ajuda do
Pure Data com instruções e exemplos de utilização. Como convenção, o arquivo
de ajuda deve ter o mesmo nome que o \external, acrescido do sufixo
\texttt{-help.pd}. Por exemplo, para o código fonte \texttt{example01.c}, que
gera o objeto \texttt{example01.pd\_linux}, escrevemos também o arquivo
\texttt{example01-help.pd}.

No próximo capítulo veremos uma forma de associar o arquivo de ajuda com a
opção de ajuda que aparece no menu contextual com um clique do botão direito
no objeto do external dentro do Pure Data.

\section{Utilizando \externals}
\label{sec:using}

Para carregar um \external em um \texttt{patch} do Pure Data em tempo de
execução, basta criar um objeto (com \texttt{CTRL+1} ou acessando o menu
\texttt{Put} $\rightarrow$ \texttt{Object}) com o caminho (relativo ou
absoluto) para o objeto compilado com a biblioteca compartilhada, omitindo a
extensão.

É possível adicionar o diretório que contém o arquivo binário do \external ao
caminho de busca do Pure Data, de forma que para acessá-lo de dentro de um
\patch não seja necessário digitar o caminho inteiro até o objeto. Isto pode
ser feito através da passagem de um parâmetro na linha de comando do Pure Data
com a opção \texttt{-path <caminho>}, ou de forma gráfica acessando a opção
\texttt{File} $\rightarrow$ \texttt{Path...} no menu do Pure Data,
como pode ser visto na figura \ref{fig:search-path}.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.7\textwidth]{path}
  \caption{Adicionando o diretório de um \external ao caminho de busca do Pure Data.}
  \label{fig:search-path}
\end{figure}

Para carregar uma biblioteca de \externals (mais de um \external no mesmo
arquivo-fonte), é possível indicar o nome da bibliotecai na linha
de comando do Pure Data utilizando a opção \texttt{-lib <biblioteca>}, ou
também graficamente através do menu \texttt{File} $\rightarrow$
\texttt{Startup...}, como pode ser visto na figura \ref{fig:lib}.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.7\textwidth]{startup}
  \caption{Adicionando uma biblioteca ao Pure Data.}
  \label{fig:lib}
\end{figure}

