% ----------------------------------------------------------------------------
% O básico de um \external
% ----------------------------------------------------------------------------

\chapter{O básico de um \external}

Escrever um \external significa seguir as recomendações da API. Peço ao leitor
bastante paciência pois este tutorial pretende andar um pouco devagar para
mostrar os passos da escrita de um \external.

\section{Um \external simples}

Como dissemos anteriormente, a arquitetura do Pure Data é organizada de acordo
com o paradigma de orientação a objetos: cada objeto gráfico do Pure Data
corresponde a uma instância de uma classe. Neste sentido, um \external está
associado a uma estrutura de dados que representa uma classe em C. Para cada
classe é necessário haver métodos de instanciação, destruição, processamento
de sinais, tratamento de mensagens, etc.

A infraestrutura mínima para o funcionamento de uma classe consiste em uma
estrutura de dados para a representação da classe, que deve ser chamada
\texttt{t\_<external>}, e dois métodos obrigatórios: \texttt{<external>\_setup()}
e \texttt{<external>\_new()}. A convenção de nomes utilizada no Pure Data é de
que toda função deve ser nomeada da forma
\texttt{<external>\_<metodo>(<argumentos>)}.

A estutura de dados que representa uma classe do Pure Data deve
obrigatoriamente possuir o primeiro atributo do tipo \texttt{t\_object}, no
qual é armazenado o objeto instanciado no momento da instanciação.  Outros
atributos podem ser adicionados a esta estrutura de maneira que cada instância
da mesma classe possua os atributos necessários para seu funcionamento. Uma
classe que acessa um arquivo, por exemplo, pode possuir como atributos uma
string para guardar o caminho e um inteiro para guardar o descritor do
arquivo.

Um exemplo de estrutura de dados para representação de uma classe chamada
\texttt{example01} consiste no seguinte:

\vspace{1em}
\begin{lstlisting}
static t_class *example01_class;

typedef struct _example01 {
  t_object x_obj;
} t_example01;
\end{lstlisting}

Sempre que um \external é carregado pelo Pure Data, o método de nome
\texttt{<external>\_setup()} é executado. No exemplo dado acima, o Pure
Data irá procurar, no arquivo binário \texttt{example01.pd\_linux} que contém
a biblioteca compartilhada, o método de nome \texttt{example01\_setup(void)}.
Este método é utilizado para realizar a inicialização da classe, informando ao
Pure Data da existência de uma nova classe no sistema e associando a ela os
métodos de instanciação e destruição, além de outras informações:

\vspace{1em}
\begin{lstlisting}
void example1_setup(void) {
  example1_class = class_new(
    gensym("example1"),         // Nome simbolico
    (t_newmethod) example1_new, // Construtor
    0,                          // Destrutor
    sizeof (t_example1),        // Tamanho dos atributos
    CLASS_NOINLET,              // Flags da classe
    0                           // Tipos dos argumentos
  );
}
\end{lstlisting}

Dentro do método \texttt{<external>\_setup()} não há limite para o número de
classes a definir, de forma que é possível definir apenas uma classe (como no
exemplo 01) ou uma biblioteca inteira com várias classes (como no exemplo 03).
A introdução de uma nova classe no sistema é realizada pela função
\texttt{class\_new()}. São parâmetros da função \texttt{class\_new()}:

\begin{itemize}
\item Nome simbólico da classe.
\item Método construtor de um objeto.
\item Método destrutor de um objeto.
\item Tamanho do espaço de dados dos atributos de um objeto.
\item Flags que definem a representação gráfica do objeto.
\item Tipos dos parâmetros a serem passados para o construtor quando da
      instanciação de um objeto (veja o próximo capítulo).
\end{itemize}

É necessário terminar a lista de tipos de parâmetros com um número inteiro 0,
para indicar ao Pure Data que a lista de tipos terminou. Consulte a
documentação da função \texttt{class\_new()} para mais
detalhes\footnote{http://pdstatic.iem.at/externals-HOWTO/node9.html\#SECTION00092100000000000000}.

O método \texttt{<external>\_new()}, que foi associado como método de
instanciação de objetos na chamada de \texttt{class\_new()}, realiza a
instanciação de objetos propriamente dita. Neste método, além da instanciação
de um novo objeto através da função \texttt{pd\_new()}, é possível definir os
valores dos atributos da estrutura de dados da classe e também inicializar
quaisquer outros contextos que sejam necessários, como por exemplo abrir
arquivos, preencher vetores, alocar memória, etc.

\vspace{1em}
\begin{lstlisting}
// Construtor da classe
void * example01_new(void) {
    t_example1 *x = (t_example1 *) pd_new(example1_class);
    return (void *) x;
}
\end{lstlisting}

Após a criação da estrutura de dados dos métodos da forma mencionada acima, a
compilação realizada da forma descrita na seção \ref{sec:compiling}, e a
criação do objeto no Pure Data como descrito na seção \ref{sec:using}, o
resultado pode ser visto na figura \ref{fig:example01working}.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.7\textwidth]{example1}
  \caption{Nosso primeiro \external do PD. Ainda inútil. :-$\left.\right)$}
  \label{fig:example01working}
\end{figure}

\section{Uma biblioteca simples}

Um mesmo método \texttt{<external>\_setup()} pode definir várias classes
diferentes. A isto damos o nome de biblioteca. Para isto, o método
\texttt{<external>\_setup()} terá o mesmo nome do arquivo com a biblioteca mas
as classes  podem ter outros nomes. Veja o exemplo 03.

\vspace{1em}
\begin{lstlisting}
void example3_setup(void) {
    post("Initializing my library");

    myobj1_class = class_new(gensym("myobj1"),
            (t_newmethod) myobj1_new, // Constructor
            0,
            sizeof (t_myobj1),
	    CLASS_NOINLET,
            0);
    class_sethelpsymbol(myobj1_class, 
	gensym("myobj1-help"));

    myobj2_class = class_new(gensym("myobj2"),
            (t_newmethod) myobj2_new, // Constructor
            0,
            sizeof (t_myobj2),
	    CLASS_NOINLET,
            0);
    class_sethelpsymbol(myobj2_class, 
	gensym("myobj2-help"));

}
\end{lstlisting}

Se o arquivo foi feito corretamente, compilado corretamente e adicionado ao
caminho do PureData, teremos o resultado.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{example3}
	\caption{Nosso primeiro \external do PD. Ainda inútil.:-)}
\end{figure}


No caso da biblioteca, podemos ter um arquivo de help para cada \external. Esta
associação é feita pela função:

\vspace{1em}
\begin{lstlisting}
class_sethelpsymbol(myclass_class, gensym("my_class-help"));
\end{lstlisting}

Um objeto pode ainda ter outros nomes ou alias. Para definir isto podemo utilizar a função class\_addcreator. Veja o exemplo:

\vspace{1em}
\begin{lstlisting}
class_addcreator((t_newmethod)medusa_new, gensym("med"), 0);
\end{lstlisting}

\section{Variáveis globais}

Você pode usar uma variável global para armazenar dados pelos seus \externals.
Esta variável será visível para todas as intâncias do \external e todas podem
alterar seu valor. Isto pode ser útil ou um desastre. (Veja o exemplo16).

\vspace{1em}
\begin{lstlisting}
int count = 0;

void * example16_new(void) {
    t_example16 *x = (t_example16 *) pd_new(example16_class);
    post("Counter value: %d",count);
    count++;
    return (void *) x;
}
\end{lstlisting}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{example16}
	\caption{Repare no output da janela principal.}
\end{figure}

Caso isto não seja desejável, o ideal é colocar suas variáveis dentro da
struct do objeto. Assim cada instância terá seu próprio contador.

\vspace{1em}
\begin{lstlisting}
static t_class *example_class;

typedef struct _example {
    t_object x_obj;
    t_int counter;
} t_example;

void * example_new(void) {
    t_example *x = (t_example *) pd_new(example_class);
    post("Counter value: %d",x->counter);
    counter++;
    return (void *) x;
}

\end{lstlisting}

