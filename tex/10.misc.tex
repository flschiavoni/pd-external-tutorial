% ----------------------------------------------------------------------------
% MISCELÂNEAS
% ----------------------------------------------------------------------------

\chapter{Miscelâneas}

Aqui temos uma lista de funções definidas pela biblioteca que permite criarmos externals 
(m\_pd.h). Não se trata de todas as funções mas de algumas que podem ser útil termos descrito
como material de referência.

\todo{Ideal mesmo era rechear esta documentação com exemplos.}
% MEM -------------------------------------------------------------------------------------------------------

\section{Gerenciamento de memória}

\code{void *getbytes(size\_t nbytes);}

\code{void *getzbytes(size\_t nbytes);}

\code{void *copybytes(void *src, size\_t nbytes);}

\code{void freebytes(void *x, size\_t nbytes);}
Desaloca um ponteiro da memória.

\code{void *resizebytes(void *x, size\_t oldsize, size\_t newsize);}

% Atoms -------------------------------------------------------------------------------------------------------

\section{Atoms}

\code{t\_float atom\_getfloat(t\_atom *a);}

\code{t\_int atom\_getint(t\_atom *a);}

\code{t\_symbol *atom\_getsymbol(t\_atom *a);}

\code{t\_symbol *atom\_gensym(t\_atom *a);}

\code{t\_float atom\_getfloatarg(int which, int argc, t\_atom *argv);}

\code{t\_int atom\_getintarg(int which, int argc, t\_atom *argv);}

\code{t\_symbol *atom\_getsymbolarg(int which, int argc, t\_atom *argv);}

\code{void atom\_string(t\_atom *a, char *buf, unsigned int bufsize);}

% Binfbuf -------------------------------------------------------------------------------------------------------

\section{Binbufs}

\code{t\_binbuf *binbuf\_new(void);}

\code{void binbuf\_free(t\_binbuf *x);}

\code{t\_binbuf *binbuf\_duplicate(t\_binbuf *y);}

\code{void binbuf\_text(t\_binbuf *x, char *text, size\_t size);}

\code{void binbuf\_gettext(t\_binbuf *x, char **bufp, int *lengthp);}

\code{void binbuf\_clear(t\_binbuf *x);}

\code{void binbuf\_add(t\_binbuf *x, int argc, t\_atom *argv);}

\code{void binbuf\_addv(t\_binbuf *x, char *fmt, ...);}

\code{void binbuf\_addbinbuf(t\_binbuf *x, t\_binbuf *y);}

\code{void binbuf\_addsemi(t\_binbuf *x);}

\code{void binbuf\_restore(t\_binbuf *x, int argc, t\_atom *argv);}

\code{void binbuf\_print(t\_binbuf *x);}

\code{int binbuf\_getnatom(t\_binbuf *x);}

\code{t\_atom *binbuf\_getvec(t\_binbuf *x);}

\code{void binbuf\_eval(t\_binbuf *x, t\_pd *target, int argc, t\_atom *argv);}

\code{int binbuf\_read(t\_binbuf *b, char *filename, char *dirname, int crflag);}

\code{int binbuf\_read\_via\_canvas(t\_binbuf *b, char *filename, t\_canvas *canvas, int crflag);}

\code{int binbuf\_read\_via\_path(t\_binbuf *b, char *filename, char *dirname, int crflag);}

\code{int binbuf\_write(t\_binbuf *x, char *filename, char *dir, int crflag);}

\code{void binbuf\_evalfile(t\_symbol *name, t\_symbol *dir);}

\code{t\_symbol *binbuf\_realizedollsym(t\_symbol *s, int ac, t\_atom *av, int tonew);}

% Clocks -------------------------------------------------------------------------------------------------------

\section{Clocks}

\code{t\_clock *clock\_new(void *owner, t\_method fn);}

\code{void clock\_set(t\_clock *x, double systime);}

\code{void clock\_delay(t\_clock *x, double delaytime);}

\code{void clock\_unset(t\_clock *x);}

\code{double clock\_getlogicaltime(void);}

\code{double clock\_getsystime(void);}
OBSOLETE; use clock\_getlogicaltime()

\code{double clock\_gettimesince(double prevsystime);}
Elapsed time in milliseconds since the given system time 

\code{double clock\_getsystimeafter(double delaytime);}

\code{void clock\_free(t\_clock *x);}

% Pure Data -------------------------------------------------------------------------------------------------------

\section{Pure data}

\code{t\_pd *pd\_new(t\_class *cls);}

\code{void pd\_free(t\_pd *x);}

\code{void pd\_bind(t\_pd *x, t\_symbol *s);}

\code{void pd\_unbind(t\_pd *x, t\_symbol *s);}

\code{t\_pd *pd\_findbyclass(t\_symbol *s, t\_class *c);} 
	Verifica se ha um objeto desta classe instanciado no patch atual.

\code{void pd\_pushsym(t\_pd *x);}

\code{void pd\_popsym(t\_pd *x);}

\code{t\_symbol *pd\_getfilename(void);}

\code{t\_symbol *pd\_getdirname(void);}

\code{void pd\_bang(t\_pd *x);}

\code{void pd\_pointer(t\_pd *x, t\_gpointer *gp);}

\code{void pd\_float(t\_pd *x, t\_float f);}

\code{void pd\_symbol(t\_pd *x, t\_symbol *s);}

\code{void pd\_list(t\_pd *x, t\_symbol *s, int argc, t\_atom *argv);}

\code{void pd\_anything(t\_pd *x, t\_symbol *s, int argc, t\_atom *argv);}

% Pointers -------------------------------------------------------------------------------------------------------

\section{Pointers}

\code{void gpointer\_init(t\_gpointer *gp);}

\code{void gpointer\_copy(const t\_gpointer *gpfrom, t\_gpointer *gpto);}

\code{void gpointer\_unset(t\_gpointer *gp);}

\code{int gpointer\_check(const t\_gpointer *gp, int headok);}

% Inlets & Outlets -------------------------------------------------------------------------------------------------------

\section{Inlets and outlets}

\code{t\_inlet *inlet\_new(t\_object *owner, t\_pd *dest, t\_symbol *s1, t\_symbol *s2);}

\code{t\_inlet *pointerinlet\_new(t\_object *owner, t\_gpointer *gp);}

\code{t\_inlet *floatinlet\_new(t\_object *owner, t\_float *fp);}

\code{t\_inlet *symbolinlet\_new(t\_object *owner, t\_symbol **sp);}

\code{t\_inlet *signalinlet\_new(t\_object *owner, t\_float f);}

\code{void inlet\_free(t\_inlet *x);}


\code{t\_outlet *outlet\_new(t\_object *owner, t\_symbol *s);}

\code{void outlet\_bang(t\_outlet *x);}

\code{void outlet\_pointer(t\_outlet *x, t\_gpointer *gp);}

\code{void outlet\_float(t\_outlet *x, t\_float f);}

\code{void outlet\_symbol(t\_outlet *x, t\_symbol *s);}

\code{void outlet\_list(t\_outlet *x, t\_symbol *s, int argc, t\_atom *argv);}

\code{void outlet\_anything(t\_outlet *x, t\_symbol *s, int argc, t\_atom *argv);}

\code{t\_symbol *outlet\_getsymbol(t\_outlet *x);}

\code{void outlet\_free(t\_outlet *x);}

\code{t\_object *pd\_checkobject(t\_pd *x);}

% Canvas -------------------------------------------------------------------------------------------------------

\section{Canvases}

\code{void glob\_setfilename(void *dummy, t\_symbol *name, t\_symbol *dir);}

\code{void canvas\_setargs(int argc, t\_atom *argv);}

\code{void canvas\_getargs(int *argcp, t\_atom **argvp);}

\code{t\_symbol *canvas\_getcurrentdir(void);}

\code{t\_glist *canvas\_getcurrent(void);}

\code{void canvas\_makefilename(t\_glist *c, char *file, char *result,int resultsize);}

\code{t\_symbol *canvas\_getdir(t\_glist *x);}

\code{char sys\_font[];} /* default typeface set in s\_main.c */

\code{char sys\_fontweight[];} /* default font weight set in s\_main.c */

\code{int sys\_fontwidth(int fontsize);}

\code{int sys\_fontheight(int fontsize);}

\code{void canvas\_dataproperties(t\_glist *x, t\_scalar *sc, t\_binbuf *b);}

\code{int canvas\_open(t\_canvas *x, const char *name, const char *ext, char *dirresult, char **nameresult, unsigned int size, int bin);}

% Classes -------------------------------------------------------------------------------------------------------

\section{Classes}

\code{t\_class *class\_new(t\_symbol *name, t\_newmethod newmethod, t\_method freemethod, size\_t size, int flags, t\_atomtype arg1, ...);}

\code{void class\_addcreator(t\_newmethod newmethod, t\_symbol *s, t\_atomtype type1, ...);}

\code{void class\_addmethod(t\_class *c, t\_method fn, t\_symbol *sel, t\_atomtype arg1, ...);}

\code{void class\_addbang(t\_class *c, t\_method fn);}

\code{void class\_addpointer(t\_class *c, t\_method fn);}

\code{void class\_doaddfloat(t\_class *c, t\_method fn);}

\code{void class\_addsymbol(t\_class *c, t\_method fn);}

\code{void class\_addlist(t\_class *c, t\_method fn);}

\code{void class\_addanything(t\_class *c, t\_method fn);}


\code{void class\_sethelpsymbol(t\_class *c, t\_symbol *s);}
Define o arquivo de help para a classe.

\code{void class\_setwidget(t\_class *c, t\_widgetbehavior *w);}
Define qual será o comportamento da GUI deste objeto. Quando esta função é chamada
o Pd não se responsabiliza mais quanto ao desenho do external.

\code{void class\_setparentwidget(t\_class *c, t\_parentwidgetbehavior *w);}

\code{t\_parentwidgetbehavior *class\_parentwidget(t\_class *c);}

\code{char *class\_getname(t\_class *c);}

\code{char *class\_gethelpname(t\_class *c);}

\code{void class\_setdrawcommand(t\_class *c);}

\code{int class\_isdrawcommand(t\_class *c);}

\code{void class\_domainsignalin(t\_class *c, int onset);}

\code{void class\_set\_extern\_dir(t\_symbol *s);}


\code{void class\_setsavefn(t\_class *c, t\_savefn f);}

\code{t\_savefn class\_getsavefn(t\_class *c);}


\code{void class\_setpropertiesfn(t\_class *c, t\_propertiesfn f);}

\code{t\_propertiesfn class\_getpropertiesfn(t\_class *c);}


% Printing -------------------------------------------------------------------------------------------------------

\section{Printing}

\code{void post(const char *fmt, ...);}
Envia um mensagem para a saída padrão do PD. Funciona de maneira similar ao printf e aceita argumentos como \%d ou \%f.
Ao contrário do printf, quebra linha no final.

\code{void startpost(const char *fmt, ...);}

\code{void poststring(const char *s);}

\code{void postfloat(t\_floatarg f);}

\code{void postatom(int argc, t\_atom *argv);}

\code{void endpost(void);}

\code{void error(const char *fmt, ...);}

\code{void verbose(int level, const char *fmt, ...);}

\code{void bug(const char *fmt, ...);}

\code{void pd\_error(void *object, const char *fmt, ...);}

\code{void sys\_logerror(const char *object, const char *s);}

\code{void sys\_unixerror(const char *object);}

\code{void sys\_ouch(void);}

% System  -------------------------------------------------------------------------------------------------------

\section{System interface routines}

\code{int sys\_isreadablefile(const char *name);}

\code{int sys\_isabsolutepath(const char *dir);}

\code{void sys\_bashfilename(const char *from, char *to);}

\code{void sys\_unbashfilename(const char *from, char *to);}

\code{int open\_via\_path(const char *name, const char *ext, const char *dir, char *dirresult, char **nameresult, unsigned int size, int bin);}

\code{int sched\_geteventno(void);}

\code{double sys\_getrealtime(void);}

\code{int (*sys\_idlehook)(void);}
Hook to add idle time computation 

% Threading -------------------------------------------------------------------------------------------------------

\section{Threading}

\code{void sys\_lock(void);}

\code{void sys\_unlock(void);}

\code{int sys\_trylock(void);}

% Signals -------------------------------------------------------------------------------------------------------

\section{Signals}

\code{t\_int *plus\_perform(t\_int *args);}

\code{t\_int *zero\_perform(t\_int *args);}

\code{t\_int *copy\_perform(t\_int *args);}


\code{void dsp\_add\_plus(t\_sample *in1, t\_sample *in2, t\_sample *out, int n);}

\code{void dsp\_add\_copy(t\_sample *in, t\_sample *out, int n);}

\code{void dsp\_add\_scalarcopy(t\_float *in, t\_sample *out, int n);}

\code{void dsp\_add\_zero(t\_sample *out, int n);}


\code{int sys\_getblksize(void);}
Retorna o tamanho do bloco de processamento do Pure Data.

\code{t\_float sys\_getsr(void);}
Retorna qual a amostragem (Sample Rate) atual do Pure Data.

\code{int sys\_get\_inchannels(void);}
Retorna a quantidade de canais de entrada do Pure Data.

\code{int sys\_get\_outchannels(void);}
Retorna a quantidade de canais de saída do Pure Data.


\code{void dsp\_add(t\_perfroutine f, int n, ...);}

\code{void dsp\_addv(t\_perfroutine f, int n, t\_int *vec);}

\code{void pd\_fft(t\_float *buf, int npoints, int inverse);}

\code{int ilog2(int n);}


\code{void mayer\_fht(t\_sample *fz, int n);}

\code{void mayer\_fft(int n, t\_sample *real, t\_sample *imag);}

\code{void mayer\_ifft(int n, t\_sample *real, t\_sample *imag);}

\code{void mayer\_realfft(int n, t\_sample *real);}

\code{void mayer\_realifft(int n, t\_sample *real);}


\code{float *cos\_table;}

\code{int canvas\_suspend\_dsp(void);}

\code{void canvas\_resume\_dsp(int oldstate);}


\code{void canvas\_update\_dsp(void);}

\code{int canvas\_dspstate;}


\code{
typedef struct \_resample \{\\
  int method;       // up/downsampling method ID\\
  t\_int downsample; // downsampling factor\\
  t\_int upsample;   // upsampling factor\\
  t\_sample *s\_vec;   // here we hold the resampled data\\
  int      s\_n;\\
  t\_sample *coeffs;  // coefficients for filtering...\\
  int      coefsize;\\
  t\_sample *buffer;  // buffer for filtering\\
  int      bufsize;\\
\} t\_resample;\\
}

\code{void resample\_init(t\_resample *x);}

\code{void resample\_free(t\_resample *x);}


\code{void resample\_dsp(t\_resample *x, t\_sample *in, int insize, t\_sample *out, int outsize, int method);}

\code{void resamplefrom\_dsp(t\_resample *x, t\_sample *in, int insize, int outsize, int method);}

\code{void resampleto\_dsp(t\_resample *x, t\_sample *out, int insize, int outsize, int method);}

% UTILITY -------------------------------------------------------------------------------------------------------

\section{Utility functions for signals}

\code{t\_float mtof(t\_float);}
Converte valores MIDI em frequencia.

\code{t\_float ftom(t\_float);}
Converte frequencias em valores MIDI.

\code{t\_float rmstodb(t\_float);}
Converte amplitudes RMS em decibéis.

\code{t\_float powtodb(t\_float);}
Converte potência em decibél.

\code{t\_float dbtorms(t\_float);}
Converte decibél para RMS.

\code{t\_float dbtopow(t\_float);}
Converte decibél para potência.

\code{t\_float q8\_sqrt(t\_float);}

\code{t\_float q8\_rsqrt(t\_float);}

% Data -------------------------------------------------------------------------------------------------------

\section{Data}

\code{t\_class *garray\_class;}

\code{int garray\_getfloatarray(t\_garray *x, int *size, t\_float **vec);}

\code{int garray\_getfloatwords(t\_garray *x, int *size, t\_word **vec);}

\code{t\_float garray\_get(t\_garray *x, t\_symbol *s, t\_int indx);}

\code{void garray\_redraw(t\_garray *x);}

\code{int garray\_npoints(t\_garray *x);}

\code{char *garray\_vec(t\_garray *x);}

\code{void garray\_resize(t\_garray *x, t\_floatarg f);}

\code{void garray\_usedindsp(t\_garray *x);}

\code{void garray\_setsaveit(t\_garray *x, int saveit);}

\code{t\_class *scalar\_class;}

\code{t\_float *value\_get(t\_symbol *s);}

\code{void value\_release(t\_symbol *s);}

\code{int value\_getfloat(t\_symbol *s, t\_float *f);}

\code{int value\_setfloat(t\_symbol *s, t\_float f);}

% GUI -------------------------------------------------------------------------------------------------------

\section{GUI interface - functions to send strings to TK}

\code{void sys\_vgui(char *fmt, ...);}
Envia comandos Tk para o canvas com argumentos.

\code{void sys\_gui(char *s);}
Envia comandos Tk para o canvas.

\code{void sys\_pretendguibytes(int n);}

\code{void sys\_queuegui(void *client, t\_glist *glist, t\_guicallbackfn f);}

\code{void sys\_unqueuegui(void *client);}


\code{void gfxstub\_new(t\_pd *owner, void *key, const char *cmd);}

\code{void gfxstub\_deleteforkey(void *key);}


\code{t\_class *glob\_pdobject;}
object to send "pd" messages


