/* Plugin structure generated by Schiavoni Pure Data external Generator */
#include "m_pd.h"

// ---------------------------------------------------
// Class definition
// ---------------------------------------------------
static t_class *postbox_class;

// ---------------------------------------------------
// Data structure definition
// ---------------------------------------------------
typedef struct _postbox {
   t_object x_obj;
   int argc;
   t_outlet * x_outlet;
   t_symbol ** messages;
} t_postbox;

// ---------------------------------------------------
// Functions signature
// ---------------------------------------------------
void * postbox_new(t_symbol *s, int argc, t_atom *argv1);// Constructor
void postbox_destroy(t_postbox *x); //Destructor
void postbox_bang_method(t_postbox *x);// Active inlet function
void postbox_float_method(t_postbox *x, t_floatarg f);// Active inlet function
void postbox_list_method(t_postbox *x, t_symbol *s, int argc, t_atom *argv);// Active inlet 
// ---------------------------------------------------
// postbox_bang
// ---------------------------------------------------
void postbox_bang_method(t_postbox *x){
   outlet_bang(x->x_outlet);
}

// ---------------------------------------------------
// postbox_float
// ---------------------------------------------------
void postbox_float_method(t_postbox *x, t_floatarg f){
   outlet_float(x->x_outlet, f);
   post("float %f", f);
}

// ---------------------------------------------------
// postbox_list
// ---------------------------------------------------
void postbox_list_method(t_postbox *x, t_symbol *s, int argc, t_atom *argv){
   post("list %s", atom_getsymbolarg(1, argc, argv)->s_name);
}

// ---------------------------------------------------
// Constructor of the class
// ---------------------------------------------------
void * postbox_new(t_symbol *s, int argc, t_atom *argv){
   t_postbox *x = (t_postbox *) pd_new(postbox_class);
   int i = 0;
   int counter = 0;
   for(; i < argc ; i++){
      if((argv + i)->a_type == A_SYMBOL)
         counter++;
   }
   x->messages = getbytes(counter * sizeof(t_symbol *));
   counter = 0;
   for(i = 0; i < argc ; i++){
      if((argv + i)->a_type == A_SYMBOL){
         x->messages[counter] = atom_getsymbol(argv + i);
         pd_bind(&x->x_obj.ob_pd, x->messages[counter]);
         counter++;
      }
   }
//   pd_bind(&x->x_obj.ob_pd, gensym("#key"));
//   pd_bind(&x->x_obj.ob_pd, gensym("#keyname"));
//   pd_bind(&x->x_obj.ob_pd, gensym("#keyup"));
   x->argc = counter;
   x->x_outlet = outlet_new(&x->x_obj, gensym("bang"));
   return (void *) x;
}

// ---------------------------------------------------
// Destroy the class
// ---------------------------------------------------
void postbox_destroy(t_postbox *x) {
   outlet_free(x->x_outlet);
   int i = 0;
   for(; i < x->argc ; i++){
      pd_unbind(&x->x_obj.ob_pd, x->messages[i]);
   }
//   pd_unbind(&x->x_obj.ob_pd, gensym("#key"));
//   pd_unbind(&x->x_obj.ob_pd, gensym("#keyname"));
//   pd_unbind(&x->x_obj.ob_pd, gensym("#keyup"));
}

// ---------------------------------------------------
// Setup
// ---------------------------------------------------
void postbox_setup(void) {
   postbox_class = class_new(gensym("postbox"),
      (t_newmethod) postbox_new, // Constructor
      (t_method) postbox_destroy, // Destructor
      sizeof (t_postbox),
      CLASS_NOINLET,
      A_GIMME,
      0);//Must always ends with a zero

   class_addbang(postbox_class, postbox_bang_method);
   class_addfloat(postbox_class, postbox_float_method);
   class_addlist(postbox_class, postbox_list_method);
}
// EOF---------------------------------------------------
